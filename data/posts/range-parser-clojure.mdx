---
title: "Range Parser Clojure üò±"
date: "2021-04-27"
preview: "/assets/tech/clojure-logo.svg"
tags:
  - "üë®‚Äçüíª Aprendizaje"
---

# Range Parser Clojure üò±

Bueno lo primero que he de decir es que es un lenguaje el cu√°l te explota la
cabeza lo m√°s grande, es el festival del par√©ntesis y todo se declara en el
aire. Enlace al [kata](https://www.codewars.com/kata/57d307fb9d84633c5100007a)

Est√© [video](https://www.youtube.com/watch?v=S28_0YDQyh8) y mucha documentaci√≥n
tanto de StackOverflow como de la p√°gina [oficial](https://clojuredocs.org/). Mi
experiencia es qu√© te saca de tu zonita de confort de un golpe, nada que ver con
lenguajes anteriores, se parece a programaci√≥n funcional de javascript. A medida
qu√© fui buscando por google fui encontrando trocitos de c√≥digo e ideas para
a√±adirlas.

<YouTube videoId="S28_0YDQyh8" title="Clojure" />

## Empezamos a explicar el Kata

Lo primero es que si vamos a definir m√°s funciones es mejor declararlas encima
de d√≥nde se vaya a usar.

Lo primero que hago es separar quitando los espacios en blanco y aplicamos
‚Äúmapcat‚Äù que devuelve el resultado de aplicar concat al resultado de aplicar el
mapa.

```clojure
(defn range-parser [s]
  (->> (clojure.string/split s #"\s*,\s*")
       (mapcat parse-range)))
```

Con esto definido llamamos a lo que ser√≠a el equivalente directo ser√≠a un switch
case. El ‚Äú:else‚Äù es el default si solo tiene un valor lo pasamos a entero y lo
devolvemos dentro de un vector.

```clojure
(defn parse-range
  [v]
  (cond
    (clojure.string/includes? v ":") (parse-step-range v)
    (clojure.string/includes? v "-") (parse-single-range v)
    :else [(Integer. v)]))
```

En el caso de que sea un rango, bueno empiezo a explicar un poquito de la
funci√≥n en clojure, el string es el comentario de la funci√≥n y ‚Äú[v]‚Äù es el valor
ya parseado dela primera funci√≥n. El uso de ‚Äúlet‚Äù nos permite declara variables
dentro del rango de su par√©ntesis. Uso range porque devuelve una secuencia
diferida de n√∫meros desde el inicio incluido hasta el final excluido. Estos
valores a√∫n son strings as√≠ que los convierto.

```clojure
(defn parse-single-range
  "Token x-y"
  [v]
  (let [[start end] (clojure.string/split v #"-")]
    (range (Integer. start) (inc (Integer. end)))))
```

Finalmente nos vamos con la √∫ltima opci√≥n la que tiene ‚Äúx-y: n‚Äù. Aqu√≠ en ves de
separar por el guion como el anterior, lo separo por el numero, quedar√≠an 3
n√∫meros, ‚Äú[x y n]‚Äù as√≠ que los asignamos a ‚Äústart‚Äù ‚Äúend‚Äù y ‚Äústep‚Äù. La parte step
nos permite ir saltando el iterador por ese valor.

```clojure
(defn parse-step-range
  "Token x-y:s"
  [v]
  (let [[start end step] (clojure.string/split v #"[^0-9]")]
    (range (Integer. start) (inc (Integer. end)) (Integer. step))))
```

Y vemos el resultado:

<MdxImage
  src="/assets/blog/range-parser-clojure/range-parser-clojure-1.png"
  alt="result-of-tests"
></MdxImage>

## Conclusi√≥n

Honestamente me puse a ver el video y tampoco fue suficiente, hace falta algo
as√≠ para lograr el ejercicio o m√°s como es mi caso:

<MdxImage
  src="/assets/blog/range-parser-clojure/range-parser-clojure-2.png"
  alt="historial"
></MdxImage>

A mi d√©jenme con mi javascript mi C# que yo eso de los par√©ntesis para todos
lados no me va, me he pegado el 50% del ejercicio as√≠‚Ä¶

<MdxImage
  src="/assets/blog/range-parser-clojure/range-parser-clojure-3.png"
  alt="console-errors"
></MdxImage>

Pero me parece un lenguaje curioso y se pueden usar las librer√≠as de java, lo
cual lo hace m√°s f√°cil. Si os gusta probar algo nuevo sin pegaros un tiro en el
proceso est√° chulo. Es poco intuitivo pero al cabo del tiempo te das cuenta que
es perfecto para modificar datos sin esfuerzo.
