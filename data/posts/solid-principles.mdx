---
title: "Principios SOLID"
date: "2022-03-30"
preview: "/assets/blog/solid-principles/solid.png"
tags:
    - "üë®‚Äçüéì Learning"
    - "üìò SOLID principles"
---

# Principios SOLID

## ¬øQu√© son los principios SOLID?

Los principios SOLID son un conjunto de principios aplicados a la programaci√≥n orientada a objetos, aplic√°ndolos correctamente ayudan a crear un software de calidad en cualquier lenguaje de programaci√≥n. Robert C Martin formulo los cinco principios de la programaci√≥n orientada a objetos que posteriormente pasaron a ser los principios SOLID.

## Los cinco principios

-   **S** ‚Üí Principio de Responsabilidad √önica
-   **O** ‚Üí Principio de Abierto-Cerrado
-   **L** ‚Üí Principio de Sustituci√≥n de Liskov
-   **I** ‚Üí Principio de Segregaci√≥n Interfaces
-   **D** ‚Üí Principio de Inversi√≥n de Dependencias

<MdxImage
    src="/assets/blog/solid-principles/solid.png"
    alt="solid principles"
></MdxImage>

## Principio de Responsabilidad √önica

Este principio se explica de una manera bastante simple:

> **_Cada componente de nuestro c√≥digo tiene que tener una √∫nica responsabilidad._**

Cuando nos referimos a componente, nos referimos a todo lo que engloba, ya sea una funci√≥n, una clase o cual estructura concreta. Siguiendo el principio, una funci√≥n tiene que tener una √∫nica responsabilidad, una clase tiene que tener √∫nica responsabilidad, etc‚Ä¶

Cuando cada componente de nuestro software tiene una √∫nica responsabilidad, entonces decimos que el nivel de cohesi√≥n es alto. Y si hablamos de cohesi√≥n estamos hablando tambi√©n de acoplamiento. El acoplamiento es el grado de relaci√≥n entre un componente y los dem√°s.

El **_Principio de Responsabilidad √önica_** nos ayuda enormemente a mejorar los niveles de acoplamiento y cohesi√≥n, lo que se traduce en un c√≥digo m√°s sencillo de dise√±ar, programar y mantener.

Ejemplo sencillo del Principio de **_Responsabilidad √önica:_**

```java
class MyClass
{
	private $counter = 0;
	public function incrementCounter(){
		$this-> counter++;
		return $this-> counter;
	}
}
```

---

## Principio de Abierto-Cerrado

El segundo principio se vio por primera vez en el libro Object-Oriented Software Construction escrito por Bertrand Meyer por el a√±o 1988 y se puede resumir en:

> **_Las entidades de software deben ser abiertas para extender, pero cerradas para modificaci√≥n._**

Cuando se refiere a abierto para extender, se refiere a extender el comportamiento de ese componente sin necesidad de modificar su c√≥digo. Los cambios en son malos, todo lo contrario, todo sistema cambia su ciclo de vida a lo largo del tiempo. Esto nos ayuda a a√±adir a los componentes nuevas funcionalidades, con la certeza de que el c√≥digo anterior no se vea comprometido y seguir√° funcionando.

Este principio se suele resolver usando **_polimorfismo_**, es decir, en vez de usar un componente principal para resolver una operaci√≥n, este lo delega en los objetos que utiliza, liber√°ndose de esa responsabilidad.

Una forma sencilla de saber que estamos violando el **_Principio de Abierto-Cerrado_**, es identificar cuales son los componentes que estamos modificando m√°s amenudeo.

Un ejemplo sencillo del **_Principio de Abierto-Cerrado:_**

```java
enum Class VehicleType{CAR,MOTORBIKE}
interface Vehicle{
	fun draw()
}
class Car: Vehicle{
	override fun draw(){
		//Draw the car
	}
}
class Motorbike: Vehicle{
	override fun draw(){
		//Draw the motorbike
	}
}
fun draw(vehicle: Vehicles){
	vehicle.draw()
}
```

Como podemos apreciar en el ejemplo estamos usando tambi√©n el **_Principio de Responsabilidad √önica._**

---

## El Principio de Sustituci√≥n de Liskov

Este principio viene a hablar sobre c√≥mo usar una de las herramientas que nos da la programaci√≥n orientada a objetos a la hora de reutilizar c√≥digo, que es la herencia y fue desarrollado por Barbara Liskov, en una conferencia all√° por el a√±o 1987. La herencia es una potente herramienta que nos permite reutilizar c√≥digo, tambi√©n es una de las herramientas que nos permite implementar el polimorfismo, que es otro de los grandes puntos fuertes de la programaci√≥n orientada a objetos.

Este principio viene a decir:

> **_Cada clase que hereda de otra puede usarse como su padre sin necesidad de conocer las diferencias entre ellas._**

La definici√≥n del principio tambi√©n puede verse de la siguiente manera:

> **_Debe ser posible utilizar cualquier objeto instancia de una subclase en lugar de cualquier objeto instancia de su superclase sin que la sem√°ntica del programa escrito en los t√©rminos de la superclase se vea afectado._**

Esto lo que nos quiere decir es que si tenemos una clase hija, deber√≠amos poder sustituir a las clases padre sin que el c√≥digo se vea comprometido. Esto es lo que nos permite es a extender una clase, sin modificar el comportamiento de la clase padre. Si un m√©todo sobrescrito no hace nada o lanza una excepci√≥n, seguramente estamos incumpliendo este principio. Otra manera de ver si estamos incumpliendo el principio, es si los test de la clase padre no funcionan para la hija.

En este ejemplo podemos ver que la clase elefante solo puede caminar, mientras que la clase perro puede caminar y saltar.

```java
open class Animal{
	open fun walk(){}
}
open class LightweightAnimal: Animal(){
	open fun jump(){}
}
fun jumpHole(animal: LightweightAnimal){
	animal.walk()
	animal.jump()
}
class Elephant : Animal()
class Dog: LightweightAnimal()
```

---

## El Principio de Segregaci√≥n de Interfaces

This.simple()

> **_Muchas interfaces espec√≠ficas son mejores que una interfaz de prop√≥sito general._**

Si desarrollamos interfaces muy grandes estamos obligando a que los objetos que implementen esta interface tengan todos los m√©todos de esta. Tambi√©n podemos enunciar el principio de la siguiente manera:

> **_Las clases que implementan interfaces no tiene que estar obligadas a implementar m√©todos que no usan._**

Debemos priorizar las interfaces peque√±as sobre las grandes. Si necesitamos una interface muy grande, es mejor que lo dividamos en una serie de interfaces m√°s peque√±as, de manera que si nuestros objetos solo implementen las interfaces que realmente necesiten y no tengamos que crear funciones que no necesitamos solo porque lo dice la interface.

El ejemplo nos muestra un uso correcto de nuestro **_Principio de Segregaci√≥n de Interfaces:_**

```java
interface ReadableStreamIface{
	open function openIt()
	open function readIt()
}
interface WritableStreamIface{
	open function writeIt()
}
class File: ReadableStreamIface, WritableStreamIface{
	open function openIt(){//...}
	open function readIt(){//...}
	open function writeIt(){//...}
}
class File: ReadableStreamIface{
	open function openIt(){//...}
	open function readIt(){//...}
}
```

---

## El Principio de Inversi√≥n de Dependencias

Y para terminar el ultimo principio de SOLID, que nos habla de una manera de desacoplar nuestros objetos. Suele definirse como:

> **_Los m√≥dulos de alto nivel no deber√≠an depender de m√≥dulos de bajo nivel, ambos deber√≠an depender de abstracciones._**

Que suele venir acompa√±ado por:

> **_Las abstracciones no deber√≠an depender de detalles, sino que los detalles deber√≠an depender de las abstracciones._**

Esto se traduce a que nuestros objetos est√°n acoplados entre si. Hay una dependencia estrecha entre nuestros objetos que deriva en tres efectos colaterales, la rigidez, la fragilidad y la inmovilidad.

Cuando hablamos de **_rigidez_** nos referimos a que nuestro sistema es dif√≠cil de modificar. Esto implica que cualquier cambio nos va a obligar a cambiar cosas en muchas partes de nuestros sistemas.

Con el termino **_fragilidad_** queremos decir que, dado que cada cambio puede tener muchos efectos inesperados en diferentes partes de nuestro c√≥digo, nuestro sistema es fr√°gil. Es decir que se puede romper con facilidad.

Si nuestro c√≥digo est√° acoplado es muy dif√≠cil que podamos usarlo en otra parte de nuestro programa. Para esto usamos el termino inmovilidad. Esto dificulta en gran medida su reutilizaci√≥n.

En resumen, un mayor acoplamiento se traduce en una mayor rigidez, un sistema m√°s fr√°gil y una **_inmovilidad_** que se traduce en, no solo un menor √≠ndice de reutilizaci√≥n sino en un mayor coste de mantenimiento.

Podemos ver la flexibilidad que le otorga esta arquitectura a nuestras clases:

```java
interface Persistence{
	fun save( shopping: Shopping)
}

interface PaymentMethod{
	fun pay( shopping: Shopping)
}

class Shopping

fun main(){
	val shoppingBasket = ShopingBasket( Server(), Paypal())
}

class ShopingBasket(
	private val persistence: Persistence,
	private val paymentMethid: PaymentMethod
){
	fun buy( shopping: Shoping){
		persistence.save( shopping)
		paymentMethid.pay( shopping)
	}
}
```
